# 성능 최적화 유스케이스 문서

## 문서 정보

- **문서명**: 성능 최적화 기능 유스케이스
- **버전**: 1.0.0
- **최종 수정일**: 2025-10-21
- **관련 문서**:
  - `/docs/userflow.md` (섹션 7.7 성능 최적화)
  - `/docs/prd.md` (섹션 8.1 성능)
- **작성자**: Development Team

---

## 개요

본 문서는 맛집 지도 서비스의 성능 최적화 기능에 대한 상세한 유스케이스를 정의합니다. 사용자 경험을 향상시키기 위한 4가지 핵심 성능 최적화 기능(지도 영역 기반 데이터 로딩, 마커 클러스터링, 검색어 입력 디바운싱, 무한 스크롤)의 동작 방식과 성능 지표를 명시합니다.

---

## 목차

1. [UC-PERF-001: 지도 영역 기반 데이터 로딩](#uc-perf-001-지도-영역-기반-데이터-로딩)
2. [UC-PERF-002: 마커 클러스터링](#uc-perf-002-마커-클러스터링)
3. [UC-PERF-003: 검색어 입력 디바운싱](#uc-perf-003-검색어-입력-디바운싱)
4. [UC-PERF-004: 무한 스크롤 (리뷰 목록)](#uc-perf-004-무한-스크롤-리뷰-목록)
5. [성능 지표 요약](#성능-지표-요약)

---

## UC-PERF-001: 지도 영역 기반 데이터 로딩

### 유스케이스 정보

- **유스케이스 ID**: UC-PERF-001
- **유스케이스 이름**: 지도 영역 기반 데이터 로딩
- **우선순위**: P0 (Must)
- **액터**: 시스템 (자동 실행)
- **관련 기능**: 지도 내비게이션, 장소 마커 표시

### 설명

사용자가 지도를 드래그하거나 줌 레벨을 변경할 때, 현재 화면에 보이는 영역(viewport)의 장소 데이터만 서버에서 로드하여 불필요한 데이터 전송과 렌더링을 최소화합니다.

### 사전 조건

- 네이버 지도 SDK가 초기화되어 있음
- 지도가 화면에 렌더링되어 있음
- 데이터베이스에 장소 데이터가 존재함

### 기본 플로우

1. **시스템**: 사용자가 지도를 드래그하거나 줌 레벨을 변경함을 감지
2. **시스템**: 지도의 `idle` 이벤트 리스너가 트리거됨 (지도 조작이 완료된 후)
3. **시스템**: 현재 지도의 경계 영역(bounds) 계산
   - 남서쪽 좌표 (lat1, lng1)
   - 북동쪽 좌표 (lat2, lng2)
4. **시스템**: 로딩 스켈레톤 UI 표시
5. **시스템**: 계산된 경계 영역을 파라미터로 API 요청 전송
   - `GET /api/places?lat1={lat1}&lng1={lng1}&lat2={lat2}&lng2={lng2}`
6. **서버**: 데이터베이스에서 해당 영역 내의 장소만 조회
   - SQL: `WHERE latitude BETWEEN lat1 AND lat2 AND longitude BETWEEN lng1 AND lng2`
   - 인덱스 활용: `idx_places_location`
7. **서버**: 필터링된 장소 목록 반환 (JSON 응답)
8. **시스템**: 기존 마커 제거
9. **시스템**: 새로운 장소 데이터로 마커 렌더링
10. **시스템**: 로딩 스켈레톤 UI 제거
11. **시스템**: 마커 표시 완료

### 대체 플로우

#### 대체 플로우 1A: 카테고리 필터가 적용된 경우

- **3A-1**: 사용자가 선택한 카테고리 필터를 확인
- **3A-2**: API 요청에 카테고리 파라미터 추가
  - `GET /api/places?lat1={lat1}&lng1={lng1}&lat2={lat2}&lng2={lng2}&category=한식,일식`
- **3A-3**: 서버는 영역 + 카테고리 조건으로 필터링
- **3A-4**: 기본 플로우 7단계로 복귀

#### 대체 플로우 1B: 이전 요청이 아직 처리 중인 경우

- **4B-1**: 진행 중인 이전 API 요청 취소 (AbortController 사용)
- **4B-2**: 새로운 요청만 처리
- **4B-3**: 기본 플로우 5단계로 복귀

### 예외 플로우

#### 예외 플로우 1E: API 요청 실패

- **6E-1**: 네트워크 에러 또는 서버 에러 발생
- **6E-2**: 에러 메시지 토스트 표시: "장소를 불러오는 중 오류가 발생했습니다"
- **6E-3**: 재시도 버튼 제공 (선택사항)
- **6E-4**: 기존 마커 유지 (제거하지 않음)
- **유스케이스 종료**

#### 예외 플로우 1E2: 타임아웃

- **6E2-1**: API 요청이 5초 내에 응답하지 않음
- **6E2-2**: 요청 취소 및 타임아웃 에러 처리
- **6E2-3**: 토스트 메시지: "요청 시간이 초과되었습니다"
- **유스케이스 종료**

#### 예외 플로우 1E3: 빈 데이터

- **7E3-1**: 서버가 빈 배열 반환 (해당 영역에 장소 없음)
- **7E3-2**: 기존 마커 모두 제거
- **7E3-3**: 안내 메시지 표시: "이 영역에 리뷰가 있는 장소가 없습니다"
- **유스케이스 종료**

### 사후 조건

- 현재 화면에 보이는 영역의 장소 마커만 지도에 표시됨
- 불필요한 데이터 전송 최소화로 네트워크 사용량 감소
- 렌더링 성능 향상

### 비기능 요구사항

| 지표 | 목표 | 측정 방법 |
|------|------|----------|
| API 응답 시간 | < 500ms (p95) | Server Timing API |
| 마커 렌더링 시간 (100개 기준) | < 500ms | Performance API |
| 데이터 전송량 감소율 | > 70% (전체 데이터 대비) | Network 패널 |
| 메모리 사용량 | < 100MB (마커 1000개 기준) | Chrome DevTools Memory |
| 데이터베이스 쿼리 실행 시간 | < 100ms | Supabase 쿼리 로그 |

### 구현 참고사항

```typescript
// 네이버 지도 idle 이벤트 리스너 예시
naver.maps.Event.addListener(map, 'idle', () => {
  const bounds = map.getBounds();
  const sw = bounds.getSW(); // 남서쪽
  const ne = bounds.getNE(); // 북동쪽

  fetchPlacesInBounds({
    lat1: sw.lat(),
    lng1: sw.lng(),
    lat2: ne.lat(),
    lng2: ne.lng(),
  });
});
```

---

## UC-PERF-002: 마커 클러스터링

### 유스케이스 정보

- **유스케이스 ID**: UC-PERF-002
- **유스케이스 이름**: 마커 클러스터링
- **우선순위**: P2 (Could)
- **액터**: 시스템 (자동 실행)
- **관련 기능**: 지도 마커 표시, 줌 레벨 변경

### 설명

지도의 줌 레벨이 낮아 많은 장소가 화면에 표시될 때, 근접한 마커들을 하나의 클러스터로 그룹화하여 표시함으로써 시각적 복잡도를 줄이고 렌더링 성능을 향상시킵니다.

### 사전 조건

- 지도가 렌더링되어 있음
- 현재 영역에 여러 개의 장소가 존재함
- 마커 클러스터링 라이브러리가 초기화되어 있음

### 기본 플로우

1. **시스템**: 현재 줌 레벨 확인
2. **시스템**: 줌 레벨이 임계값(기본값: 13) 미만인지 확인
3. **시스템**: 클러스터링 알고리즘 실행
   - 근접한 마커들을 그룹으로 묶음
   - 그룹당 포함된 마커 개수 계산
4. **시스템**: 개별 마커 대신 클러스터 마커 렌더링
   - 클러스터 아이콘 표시
   - 클러스터 내 마커 개수 표시 (예: "5")
5. **시스템**: 클러스터 마커에 클릭 이벤트 리스너 추가
6. **사용자**: 클러스터 마커 클릭 (선택)
7. **시스템**: 클러스터가 포함하는 영역으로 지도 줌인
   - 줌 레벨 +2 증가
   - 클러스터 중심으로 지도 이동 (애니메이션)
8. **시스템**: 줌인 후 클러스터 재계산
   - 클러스터가 더 작은 그룹으로 분할되거나 개별 마커로 표시됨
9. **시스템**: 마커 재렌더링 완료

### 대체 플로우

#### 대체 플로우 2A: 줌 레벨이 임계값 이상인 경우

- **2A-1**: 줌 레벨이 13 이상임을 확인
- **2A-2**: 클러스터링 비활성화
- **2A-3**: 모든 마커를 개별적으로 표시
- **유스케이스 종료**

#### 대체 플로우 2B: 사용자가 줌인하는 경우

- **1B-1**: 사용자가 줌인 액션 수행 (핀치, 더블클릭, 줌 버튼)
- **1B-2**: 줌 레벨 증가
- **1B-3**: 기본 플로우 1단계로 복귀

#### 대체 플로우 2C: 사용자가 줌아웃하는 경우

- **1C-1**: 사용자가 줌아웃 액션 수행
- **1C-2**: 줌 레벨 감소
- **1C-3**: 클러스터 그룹이 더 크게 병합됨
- **1C-4**: 기본 플로우 3단계로 복귀

### 예외 플로우

#### 예외 플로우 2E: 클러스터링 알고리즘 실행 실패

- **3E-1**: 클러스터링 계산 중 에러 발생
- **3E-2**: 콘솔에 에러 로그 출력
- **3E-3**: 폴백: 클러스터링 없이 개별 마커 표시
- **유스케이스 종료**

#### 예외 플로우 2E2: 마커 개수가 너무 많은 경우 (1000개 이상)

- **4E2-1**: 렌더링할 마커가 1000개를 초과함을 감지
- **4E2-2**: 성능 보호를 위해 상위 1000개만 표시
- **4E2-3**: 토스트 메시지: "지도를 확대하여 더 많은 장소를 확인하세요"
- **유스케이스 종료**

### 사후 조건

- 줌 레벨에 따라 마커가 클러스터링되어 표시되거나 개별적으로 표시됨
- 화면에 렌더링되는 DOM 요소 개수 감소
- 렌더링 성능 향상 및 시각적 가독성 개선

### 비기능 요구사항

| 지표 | 목표 | 측정 방법 |
|------|------|----------|
| 클러스터링 계산 시간 (500개 마커) | < 100ms | Performance API |
| 클러스터 마커 렌더링 시간 | < 200ms | Performance API |
| DOM 요소 개수 감소율 | > 80% (줌 레벨 < 13) | DOM 노드 카운트 |
| 클러스터 클릭 후 줌인 애니메이션 | 300ms | CSS transition |
| 메모리 사용량 감소 | > 50% (클러스터링 적용 시) | Chrome DevTools Memory |

### 구현 참고사항

```typescript
// 네이버 지도 마커 클러스터링 예시
import MarkerClustering from '@navermaps/marker-tools'; // 가정

const markerClustering = new MarkerClustering({
  minClusterSize: 2,
  maxZoom: 13, // 줌 레벨 13 이상에서는 클러스터링 비활성화
  map: map,
  markers: markers,
  disableClickZoom: false,
  gridSize: 60, // 클러스터링 그리드 크기 (px)
  icons: [htmlMarker1, htmlMarker2, htmlMarker3], // 클러스터 아이콘
  indexGenerator: [10, 100, 1000], // 클러스터 크기별 아이콘 인덱스
});
```

---

## UC-PERF-003: 검색어 입력 디바운싱

### 유스케이스 정보

- **유스케이스 ID**: UC-PERF-003
- **유스케이스 이름**: 검색어 입력 디바운싱
- **우선순위**: P1 (Should)
- **액터**: 시스템 (자동 실행)
- **관련 기능**: 장소 검색, 네이버 로컬 검색 API

### 설명

사용자가 검색어를 입력할 때마다 즉시 API를 호출하는 대신, 일정 시간(300ms) 동안 추가 입력이 없을 때까지 대기한 후 API를 호출하여 불필요한 네트워크 요청을 줄입니다.

### 사전 조건

- 검색 모달 또는 검색바가 활성화되어 있음
- 검색 입력 필드가 포커스되어 있음
- 네이버 로컬 검색 API가 사용 가능함

### 기본 플로우

1. **사용자**: 검색 입력 필드에 첫 번째 문자 입력 (예: "강")
2. **시스템**: 입력 이벤트 감지 (onChange)
3. **시스템**: 300ms 타이머 시작
4. **사용자**: 타이머 만료 전에 추가 문자 입력 (예: "강남")
5. **시스템**: 이전 타이머 취소
6. **시스템**: 새로운 300ms 타이머 시작
7. **사용자**: 300ms 동안 추가 입력 없음
8. **시스템**: 타이머 만료 후 콜백 함수 실행
9. **시스템**: 현재 입력값 검증
   - 최소 길이: 1자 이상
   - 공백만 있는지 확인
10. **시스템**: 검증 통과 시 검색 API 요청 전송
    - `GET /api/search?query={검색어}`
11. **서버**: 네이버 로컬 검색 API 프록시 호출
12. **서버**: 검색 결과 반환
13. **시스템**: 검색 결과 목록 렌더링
14. **시스템**: 검색 완료

### 대체 플로우

#### 대체 플로우 3A: 사용자가 검색어를 빠르게 수정하는 경우

- **4A-1**: 사용자가 연속으로 여러 문자 입력
- **4A-2**: 각 입력마다 이전 타이머가 취소되고 새 타이머 시작
- **4A-3**: 마지막 입력 후 300ms 경과 시에만 API 호출
- **4A-4**: 기본 플로우 8단계로 복귀

#### 대체 플로우 3B: 사용자가 검색어를 모두 삭제하는 경우

- **9B-1**: 입력값이 빈 문자열임을 확인
- **9B-2**: API 요청 건너뛰기
- **9B-3**: 검색 결과 목록 초기화
- **9B-4**: 최근 검색어 목록 표시 (로컬 스토리지에서 로드)
- **유스케이스 종료**

#### 대체 플로우 3C: 사용자가 엔터 키를 누르는 경우

- **7C-1**: 엔터 키 이벤트 감지
- **7C-2**: 대기 중인 타이머 즉시 취소
- **7C-3**: 즉시 API 요청 실행 (디바운싱 무시)
- **7C-4**: 기본 플로우 9단계로 복귀

### 예외 플로우

#### 예외 플로우 3E: API 요청 실패

- **11E-1**: 네트워크 에러 또는 서버 에러 발생
- **11E-2**: 에러 메시지 토스트 표시: "검색 중 오류가 발생했습니다"
- **11E-3**: 검색 결과 목록에 에러 안내 표시
- **유스케이스 종료**

#### 예외 플로우 3E2: API 할당량 초과

- **11E2-1**: 네이버 API가 429 에러 반환 (Too Many Requests)
- **11E2-2**: 캐시된 검색 결과 확인
- **11E2-3**: 캐시가 있으면 표시, 없으면 에러 메시지
- **11E2-4**: 토스트 메시지: "검색 요청이 일시적으로 제한되었습니다"
- **유스케이스 종료**

#### 예외 플로우 3E3: 검색 결과 없음

- **12E3-1**: 서버가 빈 배열 반환
- **12E3-2**: 검색 결과 목록에 안내 메시지 표시: "검색 결과가 없습니다"
- **유스케이스 종료**

### 사후 조건

- 사용자가 입력을 완료한 후에만 API 요청이 전송됨
- 불필요한 네트워크 요청 감소로 네이버 API 할당량 절약
- 서버 부하 감소

### 비기능 요구사항

| 지표 | 목표 | 측정 방법 |
|------|------|----------|
| 디바운싱 딜레이 시간 | 300ms (고정) | 코드 상수 |
| API 호출 감소율 | > 70% (디바운싱 미적용 대비) | 네트워크 요청 카운트 |
| 검색 API 응답 시간 | < 500ms (p95) | Server Timing API |
| 사용자 체감 지연 | < 500ms (입력 완료 후) | UX 테스트 |
| 네이버 API 일일 할당량 절약 | > 50% | API 사용량 로그 |

### 구현 참고사항

```typescript
// React Hook 기반 디바운싱 예시
import { useDebounce } from 'react-use';

const SearchBar = () => {
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');

  useDebounce(
    () => {
      setDebouncedQuery(searchQuery);
    },
    300,
    [searchQuery]
  );

  useEffect(() => {
    if (debouncedQuery.trim().length > 0) {
      fetchSearchResults(debouncedQuery);
    }
  }, [debouncedQuery]);

  return (
    <input
      value={searchQuery}
      onChange={(e) => setSearchQuery(e.target.value)}
      placeholder="장소 검색..."
    />
  );
};
```

---

## UC-PERF-004: 무한 스크롤 (리뷰 목록)

### 유스케이스 정보

- **유스케이스 ID**: UC-PERF-004
- **유스케이스 이름**: 무한 스크롤 (리뷰 목록)
- **우선순위**: P1 (Should)
- **액터**: 시스템 (자동 실행)
- **관련 기능**: 리뷰 목록 조회, 장소 상세 페이지

### 설명

장소의 모든 리뷰를 한 번에 로드하는 대신, 사용자가 스크롤하여 목록의 하단에 도달할 때마다 추가 리뷰를 점진적으로 로드하여 초기 로딩 시간을 단축하고 메모리 사용량을 최적화합니다.

### 사전 조건

- 장소 상세 페이지가 렌더링되어 있음
- 해당 장소에 리뷰가 존재함
- 리뷰 목록의 첫 페이지가 로드되어 있음

### 기본 플로우

1. **시스템**: 장소 상세 페이지 진입 시 첫 페이지 리뷰 로드
   - `GET /api/places/{placeId}/reviews?page=1&limit=20`
2. **시스템**: 첫 페이지 리뷰 목록 렌더링 (20개)
3. **시스템**: 무한 스크롤 감지 영역 설정 (목록 하단에서 200px 위)
4. **시스템**: Intersection Observer API로 감지 영역 관찰 시작
5. **사용자**: 리뷰 목록을 아래로 스크롤
6. **시스템**: 사용자가 감지 영역에 도달했는지 확인
7. **시스템**: 감지 영역 도달 시 다음 페이지 존재 여부 확인
   - 서버 응답의 `hasNext` 플래그 확인
8. **시스템**: 다음 페이지가 있고, 로딩 중이 아닌 경우 API 요청
   - `GET /api/places/{placeId}/reviews?page=2&limit=20`
9. **시스템**: 로딩 인디케이터 표시 (목록 하단에 스피너)
10. **서버**: 다음 페이지 리뷰 데이터 반환
11. **시스템**: 기존 목록에 새 리뷰 추가 (append)
12. **시스템**: 로딩 인디케이터 제거
13. **시스템**: 감지 영역 재설정 (새로운 목록 하단)
14. **사용자**: 계속 스크롤하면 5단계로 반복

### 대체 플로우

#### 대체 플로우 4A: 마지막 페이지에 도달한 경우

- **7A-1**: 서버 응답의 `hasNext` 플래그가 `false`임을 확인
- **7A-2**: 감지 영역 관찰 중지
- **7A-3**: 목록 하단에 안내 메시지 표시: "모든 리뷰를 확인했습니다"
- **유스케이스 종료**

#### 대체 플로우 4B: 이미 로딩 중인 경우

- **8B-1**: 현재 API 요청이 진행 중임을 확인
- **8B-2**: 중복 요청 방지 (early return)
- **유스케이스 종료**

#### 대체 플로우 4C: 사용자가 정렬 옵션을 변경하는 경우

- **1C-1**: 사용자가 정렬 옵션 변경 (최신순 → 평점순)
- **1C-2**: 기존 리뷰 목록 초기화
- **1C-3**: 페이지 번호를 1로 리셋
- **1C-4**: 새로운 정렬 기준으로 첫 페이지 로드
- **1C-5**: 기본 플로우 1단계로 복귀

### 예외 플로우

#### 예외 플로우 4E: API 요청 실패

- **10E-1**: 네트워크 에러 또는 서버 에러 발생
- **10E-2**: 로딩 인디케이터 제거
- **10E-3**: 에러 메시지 표시: "리뷰를 불러오는 중 오류가 발생했습니다"
- **10E-4**: 재시도 버튼 제공
- **10E-5**: 사용자가 재시도 버튼 클릭 시 기본 플로우 8단계로 복귀
- **유스케이스 종료**

#### 예외 플로우 4E2: 타임아웃

- **10E2-1**: API 요청이 5초 내에 응답하지 않음
- **10E2-2**: 요청 취소 및 타임아웃 에러 처리
- **10E2-3**: 토스트 메시지: "요청 시간이 초과되었습니다"
- **유스케이스 종료**

#### 예외 플로우 4E3: 페이지 데이터가 비어있는 경우

- **10E3-1**: 서버가 빈 배열 반환 (예상치 못한 상황)
- **10E3-2**: `hasNext` 플래그를 `false`로 설정
- **10E3-3**: 감지 영역 관찰 중지
- **유스케이스 종료**

### 사후 조건

- 리뷰 목록이 점진적으로 로드되어 표시됨
- 초기 페이지 로딩 시간 단축
- 메모리 사용량 최적화 (필요한 데이터만 로드)
- 사용자 경험 향상 (부드러운 스크롤 경험)

### 비기능 요구사항

| 지표 | 목표 | 측정 방법 |
|------|------|----------|
| 첫 페이지 로딩 시간 | < 1초 | Performance API (LCP) |
| 추가 페이지 로딩 시간 | < 500ms | Server Timing API |
| 페이지당 리뷰 개수 | 20개 (고정) | API 스펙 |
| 감지 영역 트리거 거리 | 200px (목록 하단에서) | 코드 상수 |
| 스크롤 성능 (프레임 드롭) | < 5% (60fps 기준) | Chrome DevTools Performance |
| 메모리 사용량 (리뷰 100개 기준) | < 50MB | Chrome DevTools Memory |

### 구현 참고사항

```typescript
// React Query Infinite Query 예시
import { useInfiniteQuery } from '@tanstack/react-query';
import { useInView } from 'react-intersection-observer';

const ReviewList = ({ placeId }) => {
  const { ref, inView } = useInView({
    threshold: 0,
    rootMargin: '200px',
  });

  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ['reviews', placeId],
    queryFn: ({ pageParam = 1 }) =>
      fetchReviews(placeId, pageParam, 20),
    getNextPageParam: (lastPage) =>
      lastPage.pagination.hasNext ? lastPage.pagination.page + 1 : undefined,
  });

  useEffect(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage]);

  return (
    <div>
      {data?.pages.map((page) =>
        page.reviews.map((review) => (
          <ReviewCard key={review.id} review={review} />
        ))
      )}
      {hasNextPage && <div ref={ref}>{isFetchingNextPage && <Spinner />}</div>}
      {!hasNextPage && <p>모든 리뷰를 확인했습니다</p>}
    </div>
  );
};
```

---

## 성능 지표 요약

### 전체 성능 최적화 목표

| 기능 | 핵심 성능 지표 | 목표값 | 우선순위 |
|------|---------------|--------|---------|
| 지도 영역 기반 로딩 | API 응답 시간 | < 500ms (p95) | P0 |
| 지도 영역 기반 로딩 | 마커 렌더링 시간 (100개) | < 500ms | P0 |
| 지도 영역 기반 로딩 | 데이터 전송량 감소 | > 70% | P0 |
| 마커 클러스터링 | 클러스터링 계산 시간 (500개) | < 100ms | P2 |
| 마커 클러스터링 | DOM 요소 개수 감소 | > 80% | P2 |
| 마커 클러스터링 | 메모리 사용량 감소 | > 50% | P2 |
| 검색어 디바운싱 | 디바운싱 딜레이 | 300ms (고정) | P1 |
| 검색어 디바운싱 | API 호출 감소율 | > 70% | P1 |
| 검색어 디바운싱 | API 할당량 절약 | > 50% | P1 |
| 무한 스크롤 | 첫 페이지 로딩 시간 | < 1초 | P1 |
| 무한 스크롤 | 추가 페이지 로딩 시간 | < 500ms | P1 |
| 무한 스크롤 | 스크롤 프레임 드롭 | < 5% | P1 |

### 통합 성능 벤치마크

#### 시나리오 1: 초기 페이지 로딩 (홈 페이지)

| 단계 | 작업 | 목표 시간 | 관련 유스케이스 |
|------|------|-----------|----------------|
| 1 | HTML 로딩 | < 500ms | - |
| 2 | 지도 SDK 초기화 | < 500ms | - |
| 3 | 현재 영역 장소 로드 | < 500ms | UC-PERF-001 |
| 4 | 마커 렌더링 | < 500ms | UC-PERF-001, UC-PERF-002 |
| **합계** | **전체 초기 로딩** | **< 2초** | **LCP 목표** |

#### 시나리오 2: 장소 검색

| 단계 | 작업 | 목표 시간 | 관련 유스케이스 |
|------|------|-----------|----------------|
| 1 | 검색어 입력 (디바운싱) | 300ms | UC-PERF-003 |
| 2 | 검색 API 호출 | < 500ms | UC-PERF-003 |
| 3 | 검색 결과 렌더링 | < 200ms | - |
| **합계** | **전체 검색 시간** | **< 1초** | **사용자 체감 지연** |

#### 시나리오 3: 리뷰 목록 스크롤

| 단계 | 작업 | 목표 시간 | 관련 유스케이스 |
|------|------|-----------|----------------|
| 1 | 스크롤 감지 | < 50ms | UC-PERF-004 |
| 2 | 다음 페이지 API 호출 | < 500ms | UC-PERF-004 |
| 3 | 추가 리뷰 렌더링 | < 200ms | UC-PERF-004 |
| **합계** | **무한 스크롤 로딩** | **< 750ms** | **부드러운 스크롤** |

### 성능 모니터링 도구

| 도구 | 용도 | 측정 항목 |
|------|------|----------|
| Lighthouse | 전체 페이지 성능 분석 | 성능 점수, LCP, FID, CLS |
| Chrome DevTools Performance | 런타임 성능 분석 | 프레임 드롭, 메모리 사용량, 이벤트 처리 시간 |
| Chrome DevTools Network | 네트워크 성능 분석 | API 응답 시간, 데이터 전송량 |
| React DevTools Profiler | React 렌더링 성능 | 컴포넌트 렌더링 시간 |
| Supabase Dashboard | 데이터베이스 성능 | 쿼리 실행 시간, 인덱스 활용도 |

---

## 부록

### A. 관련 기술 스택

- **지도 영역 기반 로딩**: 네이버 지도 SDK, React Query, Supabase PostGIS
- **마커 클러스터링**: @navermaps/marker-tools (또는 supercluster)
- **검색어 디바운싱**: react-use (useDebounce), lodash.debounce
- **무한 스크롤**: @tanstack/react-query (useInfiniteQuery), react-intersection-observer

### B. 성능 최적화 체크리스트

#### 구현 전 검증

- [ ] 각 유스케이스의 비기능 요구사항 명확히 정의
- [ ] 성능 측정 도구 및 방법 결정
- [ ] 베이스라인 성능 지표 측정 (최적화 전)

#### 구현 중 검증

- [ ] 각 기능 구현 후 단위 성능 테스트
- [ ] 크롬 DevTools로 실시간 성능 모니터링
- [ ] 메모리 누수 확인 (장시간 사용 시)

#### 구현 후 검증

- [ ] Lighthouse 성능 점수 > 90 확인
- [ ] Core Web Vitals 목표 달성 확인
- [ ] 모바일/데스크톱 환경별 성능 테스트
- [ ] 느린 네트워크 환경 (3G) 테스트
- [ ] 성능 회귀 테스트 자동화 설정

### C. 참고 문서

- [네이버 지도 API - 이벤트](https://navermaps.github.io/maps.js.ncp/docs/tutorial-3-event.html)
- [React Query - Infinite Queries](https://tanstack.com/query/latest/docs/react/guides/infinite-queries)
- [Web Performance Optimization](https://web.dev/performance/)
- [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)

---

## 문서 히스토리

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0.0 | 2025-10-21 | Development Team | 초안 작성 - 4개 유스케이스 정의 |

---

**문서 끝**
