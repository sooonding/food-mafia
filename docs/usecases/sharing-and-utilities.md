# 공유 및 유틸리티 기능 - 유스케이스 명세서

## 문서 정보

- **버전**: 1.0.0
- **최종 수정일**: 2025-10-21
- **작성자**: Development Team
- **문서 상태**: Draft
- **관련 문서**:
  - [사용자 플로우 문서](/docs/userflow.md)
  - [PRD 문서](/docs/prd.md)

---

## 개요

이 문서는 맛집 지도 서비스의 공유 및 유틸리티 기능에 대한 상세한 유스케이스를 정의합니다. 사용자 플로우 문서의 "7.5 공유 및 유틸리티" 섹션을 기반으로 작성되었으며, 다음 세 가지 주요 기능을 다룹니다:

1. 장소 공유 (링크 복사, Web Share API)
2. 길찾기 (네이버 지도 연동)
3. 최근 검색어 관리

---

## 유스케이스 목록

| UC ID | 유스케이스 이름 | 우선순위 | 상태 |
|-------|----------------|----------|------|
| UC-SU-001 | 장소 공유 - 링크 복사 | P1 | Draft |
| UC-SU-002 | 장소 공유 - Web Share API | P2 | Draft |
| UC-SU-003 | 길찾기 기능 | P2 | Draft |
| UC-SU-004 | 최근 검색어 조회 | P1 | Draft |
| UC-SU-005 | 최근 검색어 재사용 | P1 | Draft |
| UC-SU-006 | 최근 검색어 삭제 | P1 | Draft |

---

## UC-SU-001: 장소 공유 - 링크 복사

### 기본 정보

- **유스케이스 ID**: UC-SU-001
- **유스케이스 이름**: 장소 공유 - 링크 복사
- **액터**: 사용자
- **우선순위**: P1 (Should Have)
- **난이도**: Low

### 설명

사용자가 특정 장소 정보를 다른 사람과 공유하기 위해 장소 상세 페이지의 URL을 클립보드에 복사하는 기능입니다.

### 사전 조건

- 사용자가 장소 상세 페이지(`/place/[placeId]`)에 접속한 상태
- 브라우저가 Clipboard API를 지원해야 함

### 사후 조건

- 장소 상세 페이지 URL이 클립보드에 복사됨
- 사용자에게 성공 토스트 메시지가 표시됨
- 복사된 링크를 다른 앱에 붙여넣기 가능

### 기본 플로우

1. 사용자가 장소 상세 페이지에서 "공유" 버튼을 클릭한다.
2. 시스템이 공유 옵션 메뉴를 표시한다 (바텀 시트 또는 모달).
3. 사용자가 "링크 복사" 옵션을 선택한다.
4. 시스템이 현재 페이지 URL(`https://domain.com/place/[placeId]`)을 생성한다.
5. 시스템이 Clipboard API를 사용하여 URL을 클립보드에 복사한다.
6. 시스템이 "링크가 복사되었습니다" 토스트 메시지를 3초간 표시한다.
7. 공유 옵션 메뉴가 자동으로 닫힌다.
8. 유스케이스 종료.

### 대체 플로우

**A1: Web Share API 미지원 브라우저 (기본 플로우 2번에서)**

1. 시스템이 Web Share API 지원 여부를 확인한다.
2. 미지원 시, "링크 복사" 옵션만 표시한다.
3. 기본 플로우 3번으로 이동.

**A2: 직접 공유 버튼 제공 (디자인 선택사항)**

1. 공유 옵션 메뉴 없이 "공유" 버튼 클릭 시 즉시 링크 복사.
2. 기본 플로우 4번으로 이동.

### 예외 플로우

**E1: Clipboard API 미지원 (기본 플로우 5번에서)**

1. 시스템이 Clipboard API 사용 중 에러를 감지한다.
2. 시스템이 fallback 방법(textarea + execCommand)을 시도한다.
3. 성공 시 기본 플로우 6번으로 이동.
4. 실패 시 "링크 복사에 실패했습니다. 수동으로 복사해주세요" 에러 메시지 표시.
5. 시스템이 URL을 선택 가능한 텍스트 필드로 표시한다.
6. 유스케이스 종료.

**E2: 클립보드 권한 거부 (기본 플로우 5번에서)**

1. 브라우저가 클립보드 접근 권한을 거부한다.
2. 시스템이 "클립보드 접근 권한이 필요합니다" 에러 메시지를 표시한다.
3. 시스템이 URL을 선택 가능한 텍스트 필드로 표시한다.
4. 사용자가 수동으로 URL을 복사할 수 있다.
5. 유스케이스 종료.

**E3: 네트워크 오류로 페이지 URL 생성 실패 (기본 플로우 4번에서)**

1. 시스템이 현재 페이지 URL 생성에 실패한다.
2. 시스템이 "일시적인 오류가 발생했습니다" 에러 메시지를 표시한다.
3. 유스케이스 종료.

### 비기능 요구사항

#### 성능
- 클립보드 복사 실행 시간: < 100ms
- 토스트 메시지 표시 지연: < 50ms

#### 사용성
- 공유 버튼은 명확하게 인식 가능해야 함 (공유 아이콘 사용)
- 토스트 메시지는 화면 하단 또는 상단에 3초간 표시
- 복사된 URL은 정확한 장소 ID를 포함해야 함

#### 접근성
- 공유 버튼에 `aria-label="장소 공유"` 속성 추가
- 토스트 메시지에 `role="status"` 속성 추가
- 키보드로 공유 버튼 접근 가능 (Tab 키)

#### 보안
- 복사된 URL에 민감한 정보 포함 금지
- HTTPS URL만 사용

### UI/UX 요구사항

**공유 버튼**
- 위치: 장소 상세 페이지 액션 버튼 영역
- 아이콘: Lucide React `Share2` 아이콘
- 모바일: 44x44px 터치 타겟
- 데스크톱: 호버 시 툴팁 표시 ("공유")

**공유 옵션 메뉴**
- 모바일: 바텀 시트
- 데스크톱: 드롭다운 메뉴
- 애니메이션: 200ms ease-out

**토스트 메시지**
- 배경색: Success 색상 (녹색)
- 아이콘: 체크마크
- 위치: 화면 하단 중앙 (모바일), 우측 상단 (데스크톱)
- 자동 닫힘: 3초

### 관련 요구사항

- PRD 섹션 11: 제약사항 및 가정사항
- UserFlow 섹션 2.6: 공유

### 테스트 시나리오

#### TS-SU-001-01: 정상적인 링크 복사
1. 장소 상세 페이지 접속
2. "공유" 버튼 클릭
3. "링크 복사" 옵션 선택
4. 토스트 메시지 확인: "링크가 복사되었습니다"
5. 메모장에 붙여넣기하여 URL 확인
6. **예상 결과**: URL이 `https://domain.com/place/[placeId]` 형식

#### TS-SU-001-02: Clipboard API 미지원 브라우저
1. Clipboard API 미지원 브라우저에서 테스트
2. "공유" 버튼 클릭
3. Fallback 복사 방법 실행
4. **예상 결과**: 복사 성공 또는 수동 복사 UI 표시

#### TS-SU-001-03: 클립보드 권한 거부
1. 브라우저 설정에서 클립보드 권한 거부
2. "공유" 버튼 클릭
3. "링크 복사" 선택
4. **예상 결과**: 에러 메시지 및 수동 복사 UI 표시

---

## UC-SU-002: 장소 공유 - Web Share API

### 기본 정보

- **유스케이스 ID**: UC-SU-002
- **유스케이스 이름**: 장소 공유 - Web Share API
- **액터**: 사용자
- **우선순위**: P2 (Could Have)
- **난이도**: Medium

### 설명

사용자가 모바일 디바이스의 네이티브 공유 기능을 사용하여 장소 정보를 다양한 앱(카카오톡, 메신저, SNS 등)으로 직접 공유할 수 있는 기능입니다.

### 사전 조건

- 사용자가 장소 상세 페이지(`/place/[placeId]`)에 접속한 상태
- 브라우저가 Web Share API를 지원해야 함 (주로 모바일)
- 사용자가 HTTPS 환경에서 접속해야 함

### 사후 조건

- 네이티브 공유 시트가 열림
- 사용자가 선택한 앱으로 장소 정보가 공유됨
- 공유 성공 시 토스트 메시지 표시 (선택사항)

### 기본 플로우

1. 사용자가 장소 상세 페이지에서 "공유" 버튼을 클릭한다.
2. 시스템이 Web Share API 지원 여부를 확인한다.
3. 지원하는 경우, 시스템이 공유 데이터를 준비한다:
   - `title`: 장소명 (예: "맛있는 한식당")
   - `text`: 간단한 설명 (예: "맛집 지도에서 추천하는 맛집입니다!")
   - `url`: 장소 상세 페이지 URL
4. 시스템이 `navigator.share()` API를 호출한다.
5. 브라우저가 네이티브 공유 시트를 표시한다.
6. 사용자가 공유할 앱(카카오톡, 메신저, SMS 등)을 선택한다.
7. 선택한 앱에 공유 데이터가 전송된다.
8. 공유 완료 후 공유 시트가 닫힌다.
9. 시스템이 "공유가 완료되었습니다" 토스트 메시지를 표시한다 (선택사항).
10. 유스케이스 종료.

### 대체 플로우

**A1: Web Share API 미지원 브라우저 (기본 플로우 2번에서)**

1. 시스템이 Web Share API 지원 여부를 확인한다.
2. 미지원 시, UC-SU-001 (링크 복사)로 fallback한다.
3. 유스케이스 종료.

**A2: 데스크톱 환경 (기본 플로우 2번에서)**

1. 시스템이 데스크톱 환경을 감지한다.
2. Web Share API가 지원되지 않으므로 UC-SU-001로 fallback한다.
3. 유스케이스 종료.

### 예외 플로우

**E1: 사용자가 공유를 취소 (기본 플로우 6번에서)**

1. 사용자가 네이티브 공유 시트에서 "취소" 버튼을 클릭한다.
2. 공유 시트가 닫힌다.
3. 별도의 메시지 없이 장소 상세 페이지로 복귀한다.
4. 유스케이스 종료.

**E2: 공유 실패 (기본 플로우 7번에서)**

1. 선택한 앱으로 공유 중 에러가 발생한다.
2. 시스템이 에러를 감지한다.
3. 시스템이 "공유에 실패했습니다" 에러 메시지를 표시한다.
4. UC-SU-001 (링크 복사)로 fallback 옵션을 제공한다.
5. 유스케이스 종료.

**E3: HTTPS 미지원 환경 (기본 플로우 4번에서)**

1. 시스템이 HTTP 환경에서 Web Share API 호출을 시도한다.
2. 브라우저가 보안 에러를 반환한다.
3. 시스템이 UC-SU-001 (링크 복사)로 fallback한다.
4. 유스케이스 종료.

### 비기능 요구사항

#### 성능
- Web Share API 호출 시간: < 100ms
- 공유 시트 표시 지연: < 200ms

#### 사용성
- 공유 데이터는 명확하고 간결해야 함
- 공유 실패 시 대체 수단(링크 복사) 제공
- 공유 완료 후 피드백 제공 (선택사항)

#### 접근성
- 공유 버튼에 명확한 라벨 제공
- 스크린 리더 사용자에게 공유 성공 여부 알림

#### 호환성
- iOS Safari 12.2+
- Android Chrome 61+
- 데스크톱 브라우저에서는 자동 fallback

#### 보안
- HTTPS 환경에서만 작동
- 공유 데이터에 민감한 정보 포함 금지

### UI/UX 요구사항

**공유 버튼 동작**
- Web Share API 지원: 즉시 네이티브 공유 시트 열림
- 미지원: 링크 복사 기능으로 대체

**공유 데이터 포맷**
```typescript
{
  title: "맛있는 한식당",
  text: "맛집 지도에서 추천하는 맛집입니다! ⭐ 평점 4.5",
  url: "https://domain.com/place/abc123"
}
```

**네이티브 공유 시트**
- OS별 기본 UI 사용 (커스터마이징 불가)
- iOS: 하단에서 올라오는 시트
- Android: 앱 선택 다이얼로그

### 관련 요구사항

- PRD 섹션 8.4: 호환성
- UserFlow 섹션 2.6: 공유

### 테스트 시나리오

#### TS-SU-002-01: 모바일에서 정상 공유
1. iOS Safari 또는 Android Chrome에서 접속
2. 장소 상세 페이지에서 "공유" 버튼 클릭
3. 네이티브 공유 시트 확인
4. 카카오톡 선택
5. **예상 결과**: 카카오톡으로 장소 정보 공유 완료

#### TS-SU-002-02: 데스크톱에서 fallback
1. 데스크톱 Chrome에서 접속
2. "공유" 버튼 클릭
3. **예상 결과**: 링크 복사 기능 실행

#### TS-SU-002-03: 공유 취소
1. 모바일에서 "공유" 버튼 클릭
2. 공유 시트에서 "취소" 선택
3. **예상 결과**: 공유 시트 닫힘, 에러 메시지 없음

---

## UC-SU-003: 길찾기 기능

### 기본 정보

- **유스케이스 ID**: UC-SU-003
- **유스케이스 이름**: 길찾기 기능
- **액터**: 사용자
- **우선순위**: P2 (Could Have)
- **난이도**: Medium

### 설명

사용자가 장소 상세 페이지에서 해당 장소까지의 길찾기를 위해 네이버 지도 또는 카카오맵 앱/웹으로 연결되는 기능입니다.

### 사전 조건

- 사용자가 장소 상세 페이지(`/place/[placeId]`)에 접속한 상태
- 장소 정보에 위도/경도 좌표가 포함되어 있어야 함
- 인터넷 연결이 가능해야 함

### 사후 조건

- 모바일: 네이버 지도 또는 카카오맵 앱이 실행됨 (앱 미설치 시 웹으로 이동)
- 데스크톱: 새 탭에서 네이버 지도 길찾기 페이지가 열림
- 길찾기 화면에 목적지가 자동으로 설정됨

### 기본 플로우

1. 사용자가 장소 상세 페이지에서 "길찾기" 버튼을 클릭한다.
2. 시스템이 장소의 위도, 경도, 장소명 정보를 가져온다.
3. 시스템이 사용자 환경(모바일/데스크톱)을 감지한다.
4. 시스템이 길찾기 URL을 생성한다:
   - **네이버 지도**: `nmap://route/car?dlat={위도}&dlng={경도}&dname={장소명}&appname=com.example.mafia`
   - **카카오맵**: `kakaomap://route?ep={경도},{위도}&by=CAR`
   - **웹 fallback**: `https://map.naver.com/v5/directions/-/{경도},{위도}/{장소명}/car`
5. 모바일 환경인 경우:
   - 딥링크를 시도한다 (앱 실행).
   - 앱이 설치되지 않은 경우, 웹 URL로 fallback한다.
6. 데스크톱 환경인 경우:
   - 새 탭에서 네이버 지도 웹 길찾기 페이지를 연다.
7. 외부 앱/웹이 열리고 목적지가 자동 설정된 상태로 길찾기 화면이 표시된다.
8. 유스케이스 종료.

### 대체 플로우

**A1: 사용자가 지도 앱을 선택 (기본 플로우 1번에서)**

1. 사용자가 "길찾기" 버튼을 클릭한다.
2. 시스템이 지도 앱 선택 옵션을 제공한다 (바텀 시트):
   - 네이버 지도
   - 카카오맵
3. 사용자가 원하는 앱을 선택한다.
4. 선택한 앱으로 기본 플로우 4번 이동.

**A2: 현재 위치 자동 설정 (기본 플로우 4번에서)**

1. 시스템이 사용자의 현재 위치 권한을 확인한다.
2. 권한이 있는 경우, 현재 위치를 출발지로 설정한 URL을 생성한다.
3. 기본 플로우 5번으로 이동.

**A3: 웹 길찾기만 제공 (기본 플로우 4번에서)**

1. 딥링크를 사용하지 않고 모든 환경에서 웹 URL로 이동한다.
2. 기본 플로우 6번으로 이동.

### 예외 플로우

**E1: 장소 좌표 정보 없음 (기본 플로우 2번에서)**

1. 시스템이 장소 정보에서 위도/경도를 찾을 수 없다.
2. 시스템이 "길찾기 정보를 가져올 수 없습니다" 에러 메시지를 표시한다.
3. 유스케이스 종료.

**E2: 딥링크 실패 (기본 플로우 5번에서)**

1. 모바일에서 딥링크 실행에 실패한다.
2. 2초 대기 후 자동으로 웹 URL로 이동한다.
3. 기본 플로우 7번으로 이동.

**E3: 팝업 차단 (기본 플로우 6번에서)**

1. 브라우저가 새 탭 열기를 차단한다.
2. 시스템이 "팝업이 차단되었습니다. 팝업 차단을 해제해주세요" 안내 메시지를 표시한다.
3. 시스템이 "새 탭에서 열기" 버튼을 제공한다.
4. 사용자가 버튼을 클릭하면 다시 시도한다.
5. 유스케이스 종료.

**E4: 네트워크 에러 (기본 플로우 7번에서)**

1. 외부 지도 서비스 연결에 실패한다.
2. 브라우저가 에러 페이지를 표시한다.
3. 사용자가 직접 브라우저를 닫거나 뒤로가기를 한다.
4. 유스케이스 종료.

### 비기능 요구사항

#### 성능
- 길찾기 버튼 클릭 후 외부 앱/웹 실행: < 2초
- URL 생성 시간: < 50ms

#### 사용성
- 길찾기 버튼은 명확하게 인식 가능해야 함 (네비게이션 아이콘)
- 모바일: 딥링크 우선, 웹 fallback
- 데스크톱: 새 탭 열기 (현재 페이지 유지)
- 목적지가 자동으로 설정되어 사용자 입력 최소화

#### 호환성
- iOS: 네이버 지도, 카카오맵 딥링크 지원
- Android: 네이버 지도, 카카오맵 딥링크 지원
- 데스크톱: 모든 브라우저에서 웹 길찾기 지원

#### 보안
- URL 인코딩으로 XSS 방지
- HTTPS URL 사용
- 딥링크 앱 네임 지정 (네이버 API 정책 준수)

### UI/UX 요구사항

**길찾기 버튼**
- 위치: 장소 상세 페이지 액션 버튼 영역
- 아이콘: Lucide React `Navigation` 아이콘
- 텍스트: "길찾기"
- 모바일: 44x44px 터치 타겟
- 데스크톱: 호버 시 툴팁 표시

**지도 앱 선택 바텀 시트 (선택사항)**
- 네이버 지도 옵션 (로고 + 텍스트)
- 카카오맵 옵션 (로고 + 텍스트)
- 취소 버튼
- 애니메이션: 200ms ease-out

**URL 포맷**
```typescript
// 네이버 지도 (모바일 앱)
nmap://route/car?dlat=37.5665&dlng=126.9780&dname=맛있는한식당&appname=com.example.mafia

// 카카오맵 (모바일 앱)
kakaomap://route?ep=126.9780,37.5665&by=CAR

// 네이버 지도 (웹)
https://map.naver.com/v5/directions/-/126.9780,37.5665/맛있는한식당/car
```

### 관련 요구사항

- PRD 섹션 11: 제약사항 및 가정사항
- UserFlow 섹션 2.5: 길찾기

### 테스트 시나리오

#### TS-SU-003-01: 모바일에서 네이버 지도 앱 실행
1. 네이버 지도 앱이 설치된 iOS/Android 디바이스 사용
2. 장소 상세 페이지에서 "길찾기" 버튼 클릭
3. **예상 결과**: 네이버 지도 앱 실행, 목적지 자동 설정

#### TS-SU-003-02: 모바일에서 앱 미설치 시 웹 fallback
1. 네이버 지도/카카오맵 앱이 설치되지 않은 디바이스 사용
2. "길찾기" 버튼 클릭
3. **예상 결과**: 모바일 웹 브라우저에서 네이버 지도 길찾기 페이지 열림

#### TS-SU-003-03: 데스크톱에서 웹 길찾기
1. 데스크톱 브라우저에서 접속
2. "길찾기" 버튼 클릭
3. **예상 결과**: 새 탭에서 네이버 지도 웹 길찾기 페이지 열림

#### TS-SU-003-04: 장소 좌표 없음
1. 좌표 정보가 없는 장소 페이지 접속
2. "길찾기" 버튼 클릭
3. **예상 결과**: "길찾기 정보를 가져올 수 없습니다" 에러 메시지

---

## UC-SU-004: 최근 검색어 조회

### 기본 정보

- **유스케이스 ID**: UC-SU-004
- **유스케이스 이름**: 최근 검색어 조회
- **액터**: 사용자
- **우선순위**: P1 (Should Have)
- **난이도**: Low

### 설명

사용자가 검색바를 클릭했을 때 로컬 스토리지에 저장된 최근 검색어 목록을 조회하여 빠르게 재검색할 수 있도록 하는 기능입니다.

### 사전 조건

- 사용자가 홈 페이지 또는 검색 가능한 페이지에 접속한 상태
- 브라우저가 로컬 스토리지를 지원해야 함

### 사후 조건

- 최근 검색어 목록이 검색 모달/드로어에 표시됨
- 사용자가 검색어를 선택하거나 검색어를 입력할 수 있음

### 기본 플로우

1. 사용자가 헤더의 검색바를 클릭한다.
2. 시스템이 검색 모달 또는 드로어를 연다.
3. 시스템이 로컬 스토리지에서 `mafia-recent-searches` 키로 최근 검색어 데이터를 조회한다.
4. 시스템이 최근 검색어 목록을 파싱한다 (JSON 배열).
5. 시스템이 최근 검색어 목록을 시간순으로 정렬한다 (최신순).
6. 시스템이 최대 10개의 검색어를 화면에 표시한다:
   - 검색어 텍스트
   - 검색 시간 (예: "2시간 전", "어제")
   - 삭제 버튼 (X 아이콘)
7. 검색어가 없는 경우, "최근 검색어가 없습니다" 안내 메시지를 표시한다.
8. 유스케이스 종료.

### 대체 플로우

**A1: 로컬 스토리지가 비어있음 (기본 플로우 3번에서)**

1. 로컬 스토리지에 `mafia-recent-searches` 키가 없다.
2. 시스템이 빈 배열을 반환한다.
3. 기본 플로우 7번으로 이동.

**A2: 검색어가 10개 초과 (기본 플로우 6번에서)**

1. 최근 검색어가 10개를 초과한다.
2. 시스템이 최신 10개만 표시한다.
3. 나머지는 숨겨진다 (로컬 스토리지에는 유지).
4. 기본 플로우 8번으로 이동.

### 예외 플로우

**E1: 로컬 스토리지 접근 실패 (기본 플로우 3번에서)**

1. 로컬 스토리지 접근 중 에러가 발생한다 (브라우저 설정, 쿠키 차단 등).
2. 시스템이 에러를 감지하고 빈 배열을 반환한다.
3. 기본 플로우 7번으로 이동 ("최근 검색어가 없습니다" 표시).
4. 유스케이스 종료.

**E2: 잘못된 데이터 형식 (기본 플로우 4번에서)**

1. 로컬 스토리지 데이터 파싱 중 에러가 발생한다 (손상된 JSON).
2. 시스템이 에러를 로깅한다.
3. 시스템이 로컬 스토리지를 초기화한다 (빈 배열로 재설정).
4. 기본 플로우 7번으로 이동.
5. 유스케이스 종료.

### 비기능 요구사항

#### 성능
- 로컬 스토리지 조회 시간: < 50ms
- 검색 모달 렌더링 시간: < 200ms
- 최근 검색어 최대 10개로 제한하여 성능 최적화

#### 사용성
- 검색어는 최신순으로 정렬
- 검색 시간은 상대적 시간으로 표시 (예: "방금 전", "1시간 전")
- 빈 상태 안내 메시지 제공

#### 접근성
- 검색어 항목에 `role="button"` 속성
- 삭제 버튼에 `aria-label="검색어 삭제"` 속성
- 키보드로 검색어 선택 및 삭제 가능

#### 데이터 관리
- 최대 10개 저장 (초과 시 가장 오래된 항목 자동 삭제)
- 중복 검색어 제거 (재검색 시 최상단으로 이동)
- 로컬 스토리지 용량 제한 고려 (약 1KB)

### UI/UX 요구사항

**검색 모달/드로어**
- 모바일: 전체 화면 드로어 (하단에서 올라옴)
- 데스크톱: 중앙 모달 (너비 600px)
- 배경: 반투명 오버레이

**최근 검색어 목록**
- 항목 레이아웃:
  ```
  [검색 아이콘] 검색어 텍스트     [X 버튼]
                  2시간 전
  ```
- 항목 높이: 56px (모바일), 48px (데스크톱)
- 구분선: 항목 간 1px 회색 라인
- 호버 효과: 배경색 변경
- 클릭 영역: 전체 항목 (삭제 버튼 제외)

**빈 상태**
- 아이콘: 검색 아이콘 (회색)
- 텍스트: "최근 검색어가 없습니다"
- 위치: 중앙 정렬

**로컬 스토리지 데이터 구조**
```typescript
interface RecentSearch {
  query: string;        // 검색어
  timestamp: number;    // Unix timestamp (ms)
}

// localStorage key: 'mafia-recent-searches'
// Value: JSON.stringify(RecentSearch[])
```

### 관련 요구사항

- PRD 섹션 3.2.2: 장소 검색 - FR-SEARCH-003
- UserFlow 섹션 1.2: 장소 검색

### 테스트 시나리오

#### TS-SU-004-01: 정상적인 최근 검색어 표시
1. 이전에 3개의 검색어를 검색한 상태
2. 검색바 클릭
3. **예상 결과**: 최근 검색어 3개가 최신순으로 표시됨

#### TS-SU-004-02: 빈 상태
1. 로컬 스토리지를 초기화
2. 검색바 클릭
3. **예상 결과**: "최근 검색어가 없습니다" 메시지 표시

#### TS-SU-004-03: 10개 초과 검색어
1. 15개의 검색어를 검색한 상태
2. 검색바 클릭
3. **예상 결과**: 최신 10개만 표시됨

---

## UC-SU-005: 최근 검색어 재사용

### 기본 정보

- **유스케이스 ID**: UC-SU-005
- **유스케이스 이름**: 최근 검색어 재사용
- **액터**: 사용자
- **우선순위**: P1 (Should Have)
- **난이도**: Low

### 설명

사용자가 최근 검색어 목록에서 특정 검색어를 클릭하여 빠르게 재검색하는 기능입니다.

### 사전 조건

- 사용자가 검색 모달/드로어를 연 상태
- 최근 검색어 목록이 표시되어 있음
- 최소 1개 이상의 최근 검색어가 존재함

### 사후 조건

- 선택한 검색어로 검색이 실행됨
- 검색 결과가 표시됨
- 검색어가 최근 검색어 목록의 최상단으로 이동함 (중복 제거)

### 기본 플로우

1. 사용자가 검색 모달/드로어에서 최근 검색어 항목을 클릭한다.
2. 시스템이 선택한 검색어 텍스트를 가져온다.
3. 시스템이 해당 검색어로 네이버 로컬 검색 API를 호출한다 (디바운싱 없이 즉시 실행).
4. 시스템이 검색 결과를 받아온다.
5. 시스템이 검색 결과 리스트를 렌더링한다.
6. 시스템이 선택한 검색어를 로컬 스토리지에서 제거한 후 배열의 최상단에 추가한다:
   - 기존 검색어 삭제 (중복 제거)
   - 새로운 timestamp로 최상단에 추가
7. 시스템이 업데이트된 검색어 목록을 로컬 스토리지에 저장한다.
8. 유스케이스 종료.

### 대체 플로우

**A1: 검색 결과 없음 (기본 플로우 4번에서)**

1. 네이버 API가 검색 결과를 반환하지 않는다.
2. 시스템이 "검색 결과가 없습니다" 안내 메시지를 표시한다.
3. 검색어는 여전히 최근 검색어 목록에 유지된다.
4. 기본 플로우 6번으로 이동.

**A2: 검색 모달 닫기 (기본 플로우 5번 이후)**

1. 검색 결과가 표시된다.
2. 사용자가 검색 모달/드로어를 닫는다.
3. 홈 페이지 지도에서 검색 결과 확인 가능.
4. 기본 플로우 8번으로 이동.

### 예외 플로우

**E1: 네이버 API 에러 (기본 플로우 3번에서)**

1. 네이버 로컬 검색 API 호출 중 에러가 발생한다.
2. 시스템이 "검색 중 오류가 발생했습니다" 에러 메시지를 표시한다.
3. 검색어는 최근 검색어 목록에 유지된다 (업데이트 없음).
4. 유스케이스 종료.

**E2: 로컬 스토리지 저장 실패 (기본 플로우 7번에서)**

1. 로컬 스토리지 저장 중 에러가 발생한다.
2. 시스템이 에러를 로깅한다.
3. 검색 기능은 정상 작동하지만 최근 검색어 업데이트는 실패한다.
4. 사용자에게 별도의 에러 메시지는 표시하지 않는다 (UX 방해 최소화).
5. 유스케이스 종료.

**E3: 네트워크 연결 없음 (기본 플로우 3번에서)**

1. 네트워크 연결이 끊긴 상태에서 API 호출을 시도한다.
2. 시스템이 "네트워크 연결을 확인해주세요" 에러 메시지를 표시한다.
3. 유스케이스 종료.

### 비기능 요구사항

#### 성능
- 검색어 클릭 후 API 호출: 즉시 실행 (디바운싱 없음)
- API 응답 시간: < 500ms (네이버 API 기준)
- 로컬 스토리지 업데이트: < 50ms

#### 사용성
- 클릭 즉시 검색 실행 (추가 확인 불필요)
- 검색 결과는 기존 검색 플로우와 동일하게 표시
- 중복 검색어 제거로 목록 정리

#### 접근성
- 키보드로 검색어 선택 가능 (Enter 키)
- 스크린 리더에 검색 실행 안내

#### 데이터 일관성
- 검색어 중복 제거
- 최신 검색 시간으로 업데이트
- 최대 10개 제한 유지

### UI/UX 요구사항

**최근 검색어 항목 인터랙션**
- 클릭 영역: 전체 항목 (삭제 버튼 제외)
- 클릭 시 시각적 피드백: 200ms 배경색 변경
- 검색 실행 중: 로딩 스피너 표시

**검색 결과 표시**
- 검색 모달 내부에 결과 리스트 표시
- 또는 검색 모달 닫고 홈 페이지에 결과 표시 (디자인 결정)

**로컬 스토리지 업데이트 로직**
```typescript
// 중복 제거 및 최상단 추가
const updatedSearches = [
  { query: selectedQuery, timestamp: Date.now() },
  ...recentSearches.filter(s => s.query !== selectedQuery)
].slice(0, 10);
```

### 관련 요구사항

- UC-SU-004: 최근 검색어 조회
- PRD 섹션 3.2.2: 장소 검색
- UserFlow 섹션 1.2: 장소 검색

### 테스트 시나리오

#### TS-SU-005-01: 정상적인 재검색
1. 최근 검색어 목록에서 "강남 카페" 클릭
2. **예상 결과**: "강남 카페" 검색 실행, 결과 표시

#### TS-SU-005-02: 검색어 최상단 이동
1. 최근 검색어 3개 중 2번째 항목 클릭
2. 검색 후 검색바 다시 클릭
3. **예상 결과**: 선택한 검색어가 최상단으로 이동

#### TS-SU-005-03: 검색 결과 없음
1. 존재하지 않는 검색어 클릭
2. **예상 결과**: "검색 결과가 없습니다" 메시지 표시

---

## UC-SU-006: 최근 검색어 삭제

### 기본 정보

- **유스케이스 ID**: UC-SU-006
- **유스케이스 이름**: 최근 검색어 삭제
- **액터**: 사용자
- **우선순위**: P1 (Should Have)
- **난이도**: Low

### 설명

사용자가 최근 검색어 목록에서 특정 검색어를 개별적으로 삭제하거나 전체 삭제하는 기능입니다.

### 사전 조건

- 사용자가 검색 모달/드로어를 연 상태
- 최근 검색어 목록이 표시되어 있음
- 최소 1개 이상의 최근 검색어가 존재함

### 사후 조건

- 개별 삭제: 선택한 검색어가 목록에서 제거됨
- 전체 삭제: 모든 검색어가 목록에서 제거됨
- 로컬 스토리지에서 해당 데이터가 삭제됨

### 기본 플로우 - 개별 삭제

1. 사용자가 검색 모달/드로어에서 특정 검색어 항목의 삭제 버튼(X 아이콘)을 클릭한다.
2. 시스템이 클릭 이벤트를 감지한다 (이벤트 버블링 방지).
3. 시스템이 해당 검색어를 로컬 스토리지 배열에서 제거한다.
4. 시스템이 업데이트된 배열을 로컬 스토리지에 저장한다.
5. 시스템이 UI에서 해당 검색어 항목을 애니메이션과 함께 제거한다 (fade-out).
6. 남은 검색어가 없는 경우, "최근 검색어가 없습니다" 안내 메시지를 표시한다.
7. 유스케이스 종료.

### 기본 플로우 - 전체 삭제

1. 사용자가 검색 모달/드로어 상단의 "전체 삭제" 버튼을 클릭한다.
2. 시스템이 확인 다이얼로그를 표시한다: "모든 검색어를 삭제하시겠습니까?"
3. 사용자가 "확인" 버튼을 클릭한다.
4. 시스템이 로컬 스토리지의 `mafia-recent-searches` 키를 빈 배열로 초기화한다.
5. 시스템이 UI에서 모든 검색어 항목을 애니메이션과 함께 제거한다.
6. 시스템이 "최근 검색어가 없습니다" 안내 메시지를 표시한다.
7. 시스템이 "검색어가 모두 삭제되었습니다" 토스트 메시지를 표시한다.
8. 유스케이스 종료.

### 대체 플로우

**A1: 전체 삭제 취소 (전체 삭제 플로우 3번에서)**

1. 사용자가 확인 다이얼로그에서 "취소" 버튼을 클릭한다.
2. 다이얼로그가 닫힌다.
3. 검색어 목록은 그대로 유지된다.
4. 유스케이스 종료.

**A2: 확인 다이얼로그 없이 즉시 삭제 (전체 삭제 플로우 2번에서)**

1. 확인 다이얼로그 없이 즉시 전체 삭제 실행.
2. 전체 삭제 플로우 4번으로 이동.

### 예외 플로우

**E1: 로컬 스토리지 삭제 실패 (개별 삭제 플로우 4번에서)**

1. 로컬 스토리지 업데이트 중 에러가 발생한다.
2. 시스템이 에러를 로깅한다.
3. UI는 원래 상태로 복구된다 (삭제 취소).
4. 시스템이 "삭제에 실패했습니다" 에러 메시지를 표시한다.
5. 유스케이스 종료.

**E2: 동시 삭제 요청 (개별 삭제 플로우 1번에서)**

1. 사용자가 여러 검색어를 빠르게 연속 삭제한다.
2. 시스템이 각 삭제 요청을 순차적으로 처리한다 (디바운싱 또는 큐 사용).
3. 모든 삭제 완료 후 UI 업데이트.
4. 유스케이스 종료.

### 비기능 요구사항

#### 성능
- 개별 삭제 실행 시간: < 100ms
- 전체 삭제 실행 시간: < 200ms
- UI 애니메이션: 200ms fade-out

#### 사용성
- 삭제 버튼은 명확하게 인식 가능 (X 아이콘)
- 삭제 즉시 UI 반영 (애니메이션)
- 전체 삭제 시 확인 다이얼로그 제공 (실수 방지)
- 삭제 후 되돌리기 불가 (명확한 안내)

#### 접근성
- 삭제 버튼에 `aria-label="검색어 삭제"` 속성
- 전체 삭제 버튼에 `aria-label="모든 검색어 삭제"` 속성
- 키보드로 삭제 버튼 접근 가능 (Tab 키)
- 스크린 리더에 삭제 완료 안내

#### 데이터 무결성
- 삭제 후 즉시 로컬 스토리지 동기화
- 삭제 실패 시 UI 롤백
- 빈 배열 상태 유지 (null 또는 undefined 방지)

### UI/UX 요구사항

**개별 삭제 버튼**
- 위치: 각 검색어 항목 우측
- 아이콘: Lucide React `X` 아이콘
- 크기: 20x20px
- 터치 타겟: 44x44px (패딩 포함)
- 호버 효과: 빨간색 강조

**전체 삭제 버튼**
- 위치: 최근 검색어 목록 상단 우측
- 텍스트: "전체 삭제"
- 스타일: 텍스트 버튼 (밑줄 없음)
- 색상: 빨간색 또는 회색

**삭제 애니메이션**
- 개별 삭제: fade-out + slide-up (200ms)
- 전체 삭제: fade-out all items (200ms)

**확인 다이얼로그**
- 제목: "검색어 삭제"
- 메시지: "모든 검색어를 삭제하시겠습니까?"
- 버튼: "취소", "삭제" (빨간색)

### 관련 요구사항

- UC-SU-004: 최근 검색어 조회
- PRD 섹션 3.2.2: 장소 검색 - FR-SEARCH-003
- UserFlow 섹션 1.2: 장소 검색

### 테스트 시나리오

#### TS-SU-006-01: 개별 검색어 삭제
1. 최근 검색어 목록에 3개의 항목이 있는 상태
2. 2번째 항목의 삭제 버튼(X) 클릭
3. **예상 결과**: 해당 항목이 애니메이션과 함께 제거됨, 2개 남음

#### TS-SU-006-02: 마지막 검색어 삭제
1. 최근 검색어 목록에 1개의 항목만 있는 상태
2. 삭제 버튼 클릭
3. **예상 결과**: 항목 제거, "최근 검색어가 없습니다" 메시지 표시

#### TS-SU-006-03: 전체 삭제 확인
1. 최근 검색어 목록에 5개의 항목이 있는 상태
2. "전체 삭제" 버튼 클릭
3. 확인 다이얼로그에서 "삭제" 클릭
4. **예상 결과**: 모든 항목 제거, "검색어가 모두 삭제되었습니다" 토스트 표시

#### TS-SU-006-04: 전체 삭제 취소
1. "전체 삭제" 버튼 클릭
2. 확인 다이얼로그에서 "취소" 클릭
3. **예상 결과**: 검색어 목록 유지, 변경사항 없음

#### TS-SU-006-05: 연속 삭제
1. 최근 검색어 3개를 빠르게 연속 삭제
2. **예상 결과**: 모든 삭제 요청이 순차적으로 처리됨, UI 정상 업데이트

---

## 구현 우선순위

### Phase 1: MVP (필수 기능)
1. **UC-SU-004**: 최근 검색어 조회
2. **UC-SU-005**: 최근 검색어 재사용
3. **UC-SU-006**: 최근 검색어 삭제
4. **UC-SU-001**: 장소 공유 - 링크 복사

### Phase 2: 추가 기능
5. **UC-SU-003**: 길찾기 기능
6. **UC-SU-002**: 장소 공유 - Web Share API

---

## 기술 스택 및 구현 가이드

### 로컬 스토리지 관리

```typescript
// src/features/search/lib/recent-searches.ts

interface RecentSearch {
  query: string;
  timestamp: number;
}

const STORAGE_KEY = 'mafia-recent-searches';
const MAX_SEARCHES = 10;

export const getRecentSearches = (): RecentSearch[] => {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    if (!data) return [];
    return JSON.parse(data);
  } catch (error) {
    console.error('Failed to load recent searches:', error);
    return [];
  }
};

export const addRecentSearch = (query: string): void => {
  try {
    const searches = getRecentSearches();
    const updated = [
      { query, timestamp: Date.now() },
      ...searches.filter(s => s.query !== query)
    ].slice(0, MAX_SEARCHES);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
  } catch (error) {
    console.error('Failed to save recent search:', error);
  }
};

export const removeRecentSearch = (query: string): void => {
  try {
    const searches = getRecentSearches();
    const updated = searches.filter(s => s.query !== query);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
  } catch (error) {
    console.error('Failed to remove recent search:', error);
  }
};

export const clearRecentSearches = (): void => {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify([]));
  } catch (error) {
    console.error('Failed to clear recent searches:', error);
  }
};
```

### 클립보드 복사 유틸리티

```typescript
// src/lib/clipboard.ts

export const copyToClipboard = async (text: string): Promise<boolean> => {
  try {
    // Modern Clipboard API
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      return true;
    }

    // Fallback for older browsers
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.select();
    const success = document.execCommand('copy');
    document.body.removeChild(textarea);
    return success;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
};
```

### 길찾기 딥링크 유틸리티

```typescript
// src/lib/navigation.ts

interface NaverMapParams {
  latitude: number;
  longitude: number;
  placeName: string;
}

export const openNaverMapNavigation = (params: NaverMapParams): void => {
  const { latitude, longitude, placeName } = params;
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

  if (isMobile) {
    // Try deep link first
    const deepLink = `nmap://route/car?dlat=${latitude}&dlng=${longitude}&dname=${encodeURIComponent(placeName)}&appname=com.example.mafia`;
    window.location.href = deepLink;

    // Fallback to web after 2 seconds
    setTimeout(() => {
      const webUrl = `https://map.naver.com/v5/directions/-/${longitude},${latitude}/${encodeURIComponent(placeName)}/car`;
      window.open(webUrl, '_blank');
    }, 2000);
  } else {
    // Desktop: open web directly
    const webUrl = `https://map.naver.com/v5/directions/-/${longitude},${latitude}/${encodeURIComponent(placeName)}/car`;
    window.open(webUrl, '_blank');
  }
};
```

### Web Share API 유틸리티

```typescript
// src/lib/share.ts

interface ShareData {
  title: string;
  text: string;
  url: string;
}

export const canShare = (): boolean => {
  return typeof navigator.share === 'function';
};

export const share = async (data: ShareData): Promise<boolean> => {
  if (!canShare()) {
    return false;
  }

  try {
    await navigator.share(data);
    return true;
  } catch (error) {
    // User cancelled or error occurred
    console.error('Share failed:', error);
    return false;
  }
};
```

---

## 데이터 모델

### 로컬 스토리지 스키마

```typescript
// 최근 검색어
interface RecentSearch {
  query: string;        // 검색어 (예: "강남 카페")
  timestamp: number;    // Unix timestamp (ms)
}

// localStorage key: 'mafia-recent-searches'
// Value: JSON.stringify(RecentSearch[])
// Max items: 10
```

---

## 변경 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0.0 | 2025-10-21 | Development Team | 초안 작성 |

---

**문서 끝**
